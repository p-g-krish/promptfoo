// Python Code Executor for ARC-AGI
// Executes Python code generated by models and evaluates the results

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

// Extract Python code from the model's response
function extractPythonCode(output) {
  // Look for code in markdown code blocks
  const codeBlockMatch = output.match(/```python\s*([\s\S]*?)\s*```/);
  if (codeBlockMatch) {
    return codeBlockMatch[1];
  }
  
  // Look for function definition
  const funcMatch = output.match(/def\s+transform[\s\S]*?(?=\n(?!\s)|$)/m);
  if (funcMatch) {
    return funcMatch[0];
  }
  
  return null;
}

// Main evaluation function
async function evaluate(output, context) {
  const testInput = context.vars.test_input;
  const expectedOutput = context.vars.expected_output;
  
  // Extract Python code from response
  const pythonCode = extractPythonCode(output);
  
  if (!pythonCode) {
    return {
      pass: false,
      score: 0,
      reason: 'No Python code found in response'
    };
  }
  
  // Create a unique temporary file for this evaluation
  const tempId = crypto.randomBytes(8).toString('hex');
  const tempFile = path.join('/tmp', `arc_eval_${tempId}.py`);
  
  // Build the complete Python script
  const fullScript = `
import json
import sys

# Model-generated code
${pythonCode}

# Test execution
if __name__ == "__main__":
    try:
        # Parse the test input
        test_input = ${typeof testInput === 'string' ? testInput : JSON.stringify(testInput)}
        
        # Run the transform function
        if 'transform' in globals():
            result = transform(test_input)
        else:
            # Try to find any function that looks like it transforms grids
            for name, obj in globals().items():
                if callable(obj) and name not in ['print', 'json', 'sys']:
                    result = obj(test_input)
                    break
            else:
                print(json.dumps({"error": "No transform function found"}))
                sys.exit(1)
        
        # Output the result as JSON
        print(json.dumps({"result": result}))
    except Exception as e:
        print(json.dumps({"error": str(e)}))
        sys.exit(1)
`;
  
  try {
    // Write the script to temp file
    fs.writeFileSync(tempFile, fullScript);
    
    // Execute the Python script with timeout
    const pythonOutput = execSync(`python3 ${tempFile}`, {
      timeout: 5000, // 5 second timeout
      encoding: 'utf8'
    });
    
    // Parse the output
    const result = JSON.parse(pythonOutput);
    
    if (result.error) {
      return {
        pass: false,
        score: 0,
        reason: `Python execution error: ${result.error}`
      };
    }
    
    const predicted = result.result;
    
    // Validate the output
    if (!Array.isArray(predicted)) {
      return {
        pass: false,
        score: 0,
        reason: 'Output is not an array'
      };
    }
    
    // Check dimensions
    if (predicted.length !== expectedOutput.length || 
        (predicted[0] && expectedOutput[0] && predicted[0].length !== expectedOutput[0].length)) {
      return {
        pass: false,
        score: 0,
        reason: `Dimension mismatch. Expected ${expectedOutput.length}x${expectedOutput[0]?.length || 0}, got ${predicted.length}x${predicted[0]?.length || 0}`
      };
    }
    
    // Calculate pixel accuracy
    let correct = 0;
    let total = 0;
    let mismatches = [];
    
    for (let i = 0; i < expectedOutput.length; i++) {
      for (let j = 0; j < expectedOutput[i].length; j++) {
        total++;
        if (predicted[i] && predicted[i][j] === expectedOutput[i][j]) {
          correct++;
        } else {
          if (mismatches.length < 3) {
            mismatches.push(`[${i},${j}]: expected ${expectedOutput[i][j]}, got ${predicted[i]?.[j]}`);
          }
        }
      }
    }
    
    const accuracy = total > 0 ? correct / total : 0;
    const pass = accuracy === 1.0;
    
    let reason = pass ? 
      'âœ… Perfect match! Code executed successfully.' : 
      `Pixel accuracy: ${(accuracy * 100).toFixed(1)}% (${correct}/${total} pixels)`;
    
    if (!pass && mismatches.length > 0) {
      reason += '\nFirst mismatches: ' + mismatches.join(', ');
    }
    
    return {
      pass,
      score: accuracy,
      reason
    };
    
  } catch (error) {
    let errorMsg = 'Unknown error';
    
    if (error.code === 'ETIMEDOUT') {
      errorMsg = 'Python execution timed out (5s limit)';
    } else if (error.message) {
      errorMsg = error.message.split('\n')[0]; // First line of error
    }
    
    return {
      pass: false,
      score: 0,
      reason: `Execution failed: ${errorMsg}`
    };
  } finally {
    // Clean up temp file
    try {
      fs.unlinkSync(tempFile);
    } catch (e) {
      // Ignore cleanup errors
    }
  }
}

// Export for use in promptfoo
module.exports = evaluate; 